<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>opusfile: Abstract Stream Reading Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="opus_logo.svg"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">opusfile
   &#160;<span id="projectnumber">0.5</span>
   </div>
   <div id="projectbrief">Stand-alone decoder library for .opus files.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a>  </div>
  <div class="headertitle">
<div class="title">Abstract Stream Reading Interface</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpusFileCallbacks.html">OpusFileCallbacks</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The callbacks used to access non-<code>FILE</code> stream resources.  <a href="structOpusFileCallbacks.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Functions for reading from streams</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpd4385b08c3c11bcaad7ac9c007fab1ca"></a>These functions define the interface used to read from and seek in a stream of data.</p>
<p>A stream does not need to implement seeking, but the decoder will not be able to seek if it does not do so. These functions also include some convenience routines for working with standard <code>FILE</code> pointers, complete streams stored in a single block of memory, or URLs. </p>
</td></tr>
<tr class="memitem:ga7944f14ec02e9ebcb9f168188cb0a885"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stream__callbacks.html#ga7944f14ec02e9ebcb9f168188cb0a885">op_read_func</a> )(void *_stream, unsigned char *_ptr, int _nbytes)</td></tr>
<tr class="memdesc:ga7944f14ec02e9ebcb9f168188cb0a885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads up to <em>_nbytes</em> bytes of data from <em>_stream</em>.  <a href="#ga7944f14ec02e9ebcb9f168188cb0a885">More...</a><br/></td></tr>
<tr class="separator:ga7944f14ec02e9ebcb9f168188cb0a885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb69a12fa16306d7df66c41123aeda95"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stream__callbacks.html#gadb69a12fa16306d7df66c41123aeda95">op_seek_func</a> )(void *_stream, opus_int64 _offset, int _whence)</td></tr>
<tr class="memdesc:gadb69a12fa16306d7df66c41123aeda95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the position indicator for <em>_stream</em>.  <a href="#gadb69a12fa16306d7df66c41123aeda95">More...</a><br/></td></tr>
<tr class="separator:gadb69a12fa16306d7df66c41123aeda95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f81c00a725cbef4e7f4b974d4d93a7b"><td class="memItemLeft" align="right" valign="top">typedef opus_int64(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stream__callbacks.html#ga8f81c00a725cbef4e7f4b974d4d93a7b">op_tell_func</a> )(void *_stream)</td></tr>
<tr class="memdesc:ga8f81c00a725cbef4e7f4b974d4d93a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the current value of the position indicator for <em>_stream</em>.  <a href="#ga8f81c00a725cbef4e7f4b974d4d93a7b">More...</a><br/></td></tr>
<tr class="separator:ga8f81c00a725cbef4e7f4b974d4d93a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28bcd62628d28861d9d9a1c0c81d0bad"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stream__callbacks.html#ga28bcd62628d28861d9d9a1c0c81d0bad">op_close_func</a> )(void *_stream)</td></tr>
<tr class="memdesc:ga28bcd62628d28861d9d9a1c0c81d0bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the underlying stream.  <a href="#ga28bcd62628d28861d9d9a1c0c81d0bad">More...</a><br/></td></tr>
<tr class="separator:ga28bcd62628d28861d9d9a1c0c81d0bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b3714e33b1459b43445b99b55cbe75f"><td class="memItemLeft" align="right" valign="top">OP_WARN_UNUSED_RESULT void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stream__callbacks.html#ga8b3714e33b1459b43445b99b55cbe75f">op_fopen</a> (<a class="el" href="structOpusFileCallbacks.html">OpusFileCallbacks</a> *_cb, const char *_path, const char *_mode) OP_ARG_NONNULL(1) OP_ARG_NONNULL(2) OP_ARG_NONNULL(3)</td></tr>
<tr class="memdesc:ga8b3714e33b1459b43445b99b55cbe75f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a stream with <code>fopen()</code> and fills in a set of callbacks that can be used to access it.  <a href="#ga8b3714e33b1459b43445b99b55cbe75f">More...</a><br/></td></tr>
<tr class="separator:ga8b3714e33b1459b43445b99b55cbe75f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1843b587e14570e616f8cc7c4501961"><td class="memItemLeft" align="right" valign="top">OP_WARN_UNUSED_RESULT void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stream__callbacks.html#gac1843b587e14570e616f8cc7c4501961">op_fdopen</a> (<a class="el" href="structOpusFileCallbacks.html">OpusFileCallbacks</a> *_cb, int _fd, const char *_mode) OP_ARG_NONNULL(1) OP_ARG_NONNULL(3)</td></tr>
<tr class="memdesc:gac1843b587e14570e616f8cc7c4501961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a stream with <code>fdopen()</code> and fills in a set of callbacks that can be used to access it.  <a href="#gac1843b587e14570e616f8cc7c4501961">More...</a><br/></td></tr>
<tr class="separator:gac1843b587e14570e616f8cc7c4501961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae63ceff71d9602c68f4db1c91b480fde"><td class="memItemLeft" align="right" valign="top">OP_WARN_UNUSED_RESULT void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stream__callbacks.html#gae63ceff71d9602c68f4db1c91b480fde">op_freopen</a> (<a class="el" href="structOpusFileCallbacks.html">OpusFileCallbacks</a> *_cb, const char *_path, const char *_mode, void *_stream) OP_ARG_NONNULL(1) OP_ARG_NONNULL(2) OP_ARG_NONNULL(3) OP_ARG_NONNULL(4)</td></tr>
<tr class="memdesc:gae63ceff71d9602c68f4db1c91b480fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a stream with <code>freopen()</code> and fills in a set of callbacks that can be used to access it.  <a href="#gae63ceff71d9602c68f4db1c91b480fde">More...</a><br/></td></tr>
<tr class="separator:gae63ceff71d9602c68f4db1c91b480fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83231f1733af83c7940b0262f1a1ffb5"><td class="memItemLeft" align="right" valign="top">OP_WARN_UNUSED_RESULT void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stream__callbacks.html#ga83231f1733af83c7940b0262f1a1ffb5">op_mem_stream_create</a> (<a class="el" href="structOpusFileCallbacks.html">OpusFileCallbacks</a> *_cb, const unsigned char *_data, size_t _size) OP_ARG_NONNULL(1)</td></tr>
<tr class="memdesc:ga83231f1733af83c7940b0262f1a1ffb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a stream that reads from the given block of memory.  <a href="#ga83231f1733af83c7940b0262f1a1ffb5">More...</a><br/></td></tr>
<tr class="separator:ga83231f1733af83c7940b0262f1a1ffb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33bf9edd6949f8125456b2c8a1591010"><td class="memItemLeft" align="right" valign="top">OP_WARN_UNUSED_RESULT void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stream__callbacks.html#ga33bf9edd6949f8125456b2c8a1591010">op_url_stream_vcreate</a> (<a class="el" href="structOpusFileCallbacks.html">OpusFileCallbacks</a> *_cb, const char *_url, va_list _ap) OP_ARG_NONNULL(1) OP_ARG_NONNULL(2)</td></tr>
<tr class="memdesc:ga33bf9edd6949f8125456b2c8a1591010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a stream that reads from the given URL.  <a href="#ga33bf9edd6949f8125456b2c8a1591010">More...</a><br/></td></tr>
<tr class="separator:ga33bf9edd6949f8125456b2c8a1591010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c588fac7542057282b50a5bd2dbb35a"><td class="memItemLeft" align="right" valign="top">OP_WARN_UNUSED_RESULT void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stream__callbacks.html#ga5c588fac7542057282b50a5bd2dbb35a">op_url_stream_create</a> (<a class="el" href="structOpusFileCallbacks.html">OpusFileCallbacks</a> *_cb, const char *_url,...) OP_ARG_NONNULL(1) OP_ARG_NONNULL(2)</td></tr>
<tr class="memdesc:ga5c588fac7542057282b50a5bd2dbb35a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a stream that reads from the given URL.  <a href="#ga5c588fac7542057282b50a5bd2dbb35a">More...</a><br/></td></tr>
<tr class="separator:ga5c588fac7542057282b50a5bd2dbb35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga7944f14ec02e9ebcb9f168188cb0a885"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* op_read_func)(void *_stream, unsigned char *_ptr, int _nbytes)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads up to <em>_nbytes</em> bytes of data from <em>_stream</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">_stream</td><td>The stream to read from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">_ptr</td><td>The buffer to store the data in. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">_nbytes</td><td>The maximum number of bytes to read. This function may return fewer, though it will not return zero unless it reaches end-of-file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes successfully read, or a negative value on error. </dd></dl>

</div>
</div>
<a class="anchor" id="gadb69a12fa16306d7df66c41123aeda95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* op_seek_func)(void *_stream, opus_int64 _offset, int _whence)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the position indicator for <em>_stream</em>. </p>
<p>The new position, measured in bytes, is obtained by adding <em>_offset</em> bytes to the position specified by <em>_whence</em>. If <em>_whence</em> is set to <code>SEEK_SET</code>, <code>SEEK_CUR</code>, or <code>SEEK_END</code>, the offset is relative to the start of the stream, the current position indicator, or end-of-file, respectively. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success. </td></tr>
    <tr><td class="paramname">-1</td><td>Seeking is not supported or an error occurred. <code>errno</code> need not be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8f81c00a725cbef4e7f4b974d4d93a7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef opus_int64(* op_tell_func)(void *_stream)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains the current value of the position indicator for <em>_stream</em>. </p>
<dl class="section return"><dt>Returns</dt><dd>The current position indicator. </dd></dl>

</div>
</div>
<a class="anchor" id="ga28bcd62628d28861d9d9a1c0c81d0bad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* op_close_func)(void *_stream)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the underlying stream. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success. </td></tr>
    <tr><td class="paramname">EOF</td><td>An error occurred. <code>errno</code> need not be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga8b3714e33b1459b43445b99b55cbe75f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OP_WARN_UNUSED_RESULT void* op_fopen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structOpusFileCallbacks.html">OpusFileCallbacks</a> *&#160;</td>
          <td class="paramname"><em>_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens a stream with <code>fopen()</code> and fills in a set of callbacks that can be used to access it. </p>
<p>This is useful to avoid writing your own portable 64-bit seeking wrappers, and also avoids cross-module linking issues on Windows, where a <code>FILE *</code> must be accessed by routines defined in the same module that opened it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">_cb</td><td>The callbacks to use for this file. If there is an error opening the file, nothing will be filled in here. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">_path</td><td>The path to the file to open. On Windows, this string must be UTF-8 (to allow access to files whose names cannot be represented in the current MBCS code page). All other systems use the native character encoding. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">_mode</td><td>The mode to open the file in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A stream handle to use with the callbacks, or <code>NULL</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="gac1843b587e14570e616f8cc7c4501961"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OP_WARN_UNUSED_RESULT void* op_fdopen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structOpusFileCallbacks.html">OpusFileCallbacks</a> *&#160;</td>
          <td class="paramname"><em>_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens a stream with <code>fdopen()</code> and fills in a set of callbacks that can be used to access it. </p>
<p>This is useful to avoid writing your own portable 64-bit seeking wrappers, and also avoids cross-module linking issues on Windows, where a <code>FILE *</code> must be accessed by routines defined in the same module that opened it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">_cb</td><td>The callbacks to use for this file. If there is an error opening the file, nothing will be filled in here. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">_fd</td><td>The file descriptor to open. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">_mode</td><td>The mode to open the file in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A stream handle to use with the callbacks, or <code>NULL</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="gae63ceff71d9602c68f4db1c91b480fde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OP_WARN_UNUSED_RESULT void* op_freopen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structOpusFileCallbacks.html">OpusFileCallbacks</a> *&#160;</td>
          <td class="paramname"><em>_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>_stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens a stream with <code>freopen()</code> and fills in a set of callbacks that can be used to access it. </p>
<p>This is useful to avoid writing your own portable 64-bit seeking wrappers, and also avoids cross-module linking issues on Windows, where a <code>FILE *</code> must be accessed by routines defined in the same module that opened it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">_cb</td><td>The callbacks to use for this file. If there is an error opening the file, nothing will be filled in here. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">_path</td><td>The path to the file to open. On Windows, this string must be UTF-8 (to allow access to files whose names cannot be represented in the current MBCS code page). All other systems use the native character encoding. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">_mode</td><td>The mode to open the file in. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">_stream</td><td>A stream previously returned by <a class="el" href="group__stream__callbacks.html#ga8b3714e33b1459b43445b99b55cbe75f" title="Opens a stream with fopen() and fills in a set of callbacks that can be used to access it...">op_fopen()</a>, <a class="el" href="group__stream__callbacks.html#gac1843b587e14570e616f8cc7c4501961" title="Opens a stream with fdopen() and fills in a set of callbacks that can be used to access it...">op_fdopen()</a>, or <a class="el" href="group__stream__callbacks.html#gae63ceff71d9602c68f4db1c91b480fde" title="Opens a stream with freopen() and fills in a set of callbacks that can be used to access it...">op_freopen()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A stream handle to use with the callbacks, or <code>NULL</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga83231f1733af83c7940b0262f1a1ffb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OP_WARN_UNUSED_RESULT void* op_mem_stream_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structOpusFileCallbacks.html">OpusFileCallbacks</a> *&#160;</td>
          <td class="paramname"><em>_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a stream that reads from the given block of memory. </p>
<p>This block of memory must contain the complete stream to decode. This is useful for caching small streams (e.g., sound effects) in RAM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">_cb</td><td>The callbacks to use for this stream. If there is an error creating the stream, nothing will be filled in here. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">_data</td><td>The block of memory to read from. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">_size</td><td>The size of the block of memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A stream handle to use with the callbacks, or <code>NULL</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga33bf9edd6949f8125456b2c8a1591010"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OP_WARN_UNUSED_RESULT void* op_url_stream_vcreate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structOpusFileCallbacks.html">OpusFileCallbacks</a> *&#160;</td>
          <td class="paramname"><em>_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>_url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>_ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a stream that reads from the given URL. </p>
<p>This function behaves identically to <a class="el" href="group__stream__callbacks.html#ga5c588fac7542057282b50a5bd2dbb35a" title="Creates a stream that reads from the given URL. ">op_url_stream_create()</a>, except that it takes a va_list instead of a variable number of arguments. It does not call the <code>va_end</code> macro, and because it invokes the <code>va_arg</code> macro, the value of <em>_ap</em> is undefined after the call. </p>
<dl class="section note"><dt>Note</dt><dd>If you use this function, you must link against <code>libopusurl</code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">_cb</td><td>The callbacks to use for this stream. If there is an error creating the stream, nothing will be filled in here. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">_url</td><td>The URL to read from. Currently only the &lt;file:&gt;, &lt;http:&gt;, and &lt;https:&gt; schemes are supported. Both &lt;http:&gt; and &lt;https:&gt; may be disabled at compile time, in which case opening such URLs will always fail. Currently this only supports URIs. IRIs should be converted to UTF-8 and URL-escaped, with internationalized domain names encoded in punycode, before passing them to this function. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">_ap</td><td>A list of the <a class="el" href="group__url__options.html">optional flags</a> to use. This is a variable-length list of options terminated with <code>NULL</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A stream handle to use with the callbacks, or <code>NULL</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5c588fac7542057282b50a5bd2dbb35a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OP_WARN_UNUSED_RESULT void* op_url_stream_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structOpusFileCallbacks.html">OpusFileCallbacks</a> *&#160;</td>
          <td class="paramname"><em>_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>_url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a stream that reads from the given URL. </p>
<dl class="section note"><dt>Note</dt><dd>If you use this function, you must link against <code>libopusurl</code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">_cb</td><td>The callbacks to use for this stream. If there is an error creating the stream, nothing will be filled in here. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">_url</td><td>The URL to read from. Currently only the &lt;file:&gt;, &lt;http:&gt;, and &lt;https:&gt; schemes are supported. Both &lt;http:&gt; and &lt;https:&gt; may be disabled at compile time, in which case opening such URLs will always fail. Currently this only supports URIs. IRIs should be converted to UTF-8 and URL-escaped, with internationalized domain names encoded in punycode, before passing them to this function. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">...</td><td>The <a class="el" href="group__url__options.html">optional flags</a> to use. This is a variable-length list of options terminated with <code>NULL</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A stream handle to use with the callbacks, or <code>NULL</code> on error. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
